---
layout: post
title: Range header, I choose you!
---
<p>I was looking around for a semantic way to do pagination in the HTTP API for a small personal project this last weekend.  I wasn't really satisfied with the OData pattern of using query string arguments, like  <code>$skip</code> and  <code>$top</code>.  For one, they didn't seem <em>semantic</em> in the query string.  It seems to me that queries on the resource belong in the query string whereas flow control, rate limiting, pagination, and etc. belong in the the HTTP/TCP/IP headers.</p>
<p>You could argue that skip and top queries <em>are</em> queries on the resource.  This may be true, but even with that being said, pagination is still an additional concern on top of these types of queries.  For example, I may want to look at a list of the top one thousand donors to my political campaign, but I only want to look at this list ten at a time.  Just because you can get this behavior by mucking with the query string doesn't make it the right place to do it.</p>
<p>I happened upon <a href="http://stackoverflow.com/questions/924472/paging-in-a-rest-collection">a question on Stack Overflow</a> that discussed using the Range HTTP header for pagination purposes.  The conclusion there was to use a different approach (mimicking Atom), but I disagree with thier conclusion.  I feel that the Range header could be very successfully with only a little effort.</p>

<h2>Why is the Range header a good fit?</h2>
<p>The Range header is normally used by browsers to request specific byte-ranges of binary files.  It is what powers the pause-and-resume functionality of almost every download manager in existence.  I was tempted, at first, to simply conclude that usage of the Range header for any purpose other than pause-and-resume would be an abuse.</p>
<p>
  However, RFC 2616 has <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.2">this to say about the Range header</a>:
  <blockquote>
    HTTP retrieval requests using conditional or unconditional GET methods MAY request one or more sub-ranges of the entity, instead of the entire entity, using the Range request header, which applies to the entity returned as the result of the request.
  </blockquote>
  Our entity is a collection of objects, and we are requesting "sub-ranges of the entity, instead of the entire entity."  This is a perfect fit.
</p>

<h2>How does it measure up?</h2>

<p>So, from the spec, it looks like the Range header was designed specifically to handle this concern, but how does this play out in practice?  It would be foolish to just commit to using the header without making sure it was up to the task.</p>
<p>Let's evaluate its behavior in contrast to OData-style pagination.</p>

<h3>Querying the root of the collection.</h3>

<p><strong>OData-style</strong></p>
<p>Request</p>
<blockquote>
  <code>GET /users</code>
</blockquote>
<p>Response</p>
<blockquote>
  <code>200 OK
  <br />
  <br />[ 0..9 ]</code>
</blockquote>

<p><strong>Range-header-style</strong></p>
<p>Request</p>
<blockquote>
  <code>GET /users</code>
</blockquote>
<p>Response</p>
<blockquote>
  <code>200 OK
  <br />Accept-Ranges: users
  <br />Content-Range: users 0-9/200
  <br />
  <br />[ 0..9 ]</code>
</blockquote>

<p><strong>Comparison</strong></p>
<p>Both of these have defaults for what the user is allowed to request (limited to 10), but the Range header style would automatically send back the count, without $inlinecount being specified.  You would simply need to know where to look. The Accept-Ranges header signals that the <code>users</code> range is accepted for range requests and implies that a <code>Content-Ranes</code> may be present.</p>
<p>Interestingly, the response code for the Range header style is  <code>200</code> rather than <code>206</code> because the request was missing the Range header itself.  Accept-Range and Content-Range headers are still allowed in the response, keeping it semantically complete.</p>
<p>The OData-style, in contrast, will not automatically include the count of the collection.  Event if there were a sidechannel in this request where the count was included, there is no discoverability of this fact.</p>

<h3>Pulling the first page of results normally.</h3>

<p><strong>OData-style</strong></p>
<p>Request</p>
<blockquote>
  <code>GET /users?$skip=0&amp;$top=10&amp;$inlinecount=allpages</code>
</blockquote>
<p>Response</p>
<blockquote>
  <code>200 OK
  <br />X-Some-Sidechannel: count=200
  <br />
  <br />[ 0..19 ]</code>
</blockquote>

<p><strong>Range-header-style</strong></p>
<p>Request</p>
<blockquote>
  <code>GET /users
  <br />Range: users=10-19</code>
</blockquote>
<p>Response</p>
<blockquote>
  <code>209 Partial Content
  <br />Accept-Ranges: users
  <br />Content-Range: users 10-19/200
  <br />
  <br />[ 10..19 ]</code>
</blockquote>

<p><strong>Comparison</strong></p>
<p>Since the request was made with a Range header, the right side is allowed to respond with a <code>209 Partial Content</code> response code, indicating the presence of the Content-Range response header.</p>
<p>OData had to specify the <code>$inlinecount=allpages</code> parameter in order to get the full length of the filtered collection, bloating the URL.</p>
<p>
  Additionally, the Range header style is allowed to return a Content-Range response looking something like this:
  <blockquote>
    <code>Content-Range: 200-250/*</code>
  </blockquote>
  This indicates that the full count is not included, possibly because it is too expensive to calculate.  This is often the case for complex queries.  This flexibility allows the server to chose whether or not to calculate the total length, based on the particular query at hand. In the OData version, however, the <code>$inlinecount</code> parameter is a command to get the count.  The server is not free to withold the count when it is expensive or difficult to obtain.
</p>

<h3>Pulling subsequent pages of data.</h3>
<p>Both systems perform roughly the same for pages in the middle of the collection.</p>

<h3>Requesting past the end of the collection.</h3>

<p><strong>OData-style</strong></p>
<p>Request</p>
<blockquote>
  <code>GET /users?$skip=1000</code>
</blockquote>
<p>Response</p>
<blockquote>
  <code>200 OK
  <br />
  <br />[]</code>
</blockquote>

<p><strong>Range-header-style</strong></p>
<p>Request</p>
<p>
  <blockquote>
    <code>GET /users
    <br />Range: users=1000-</code>
  </blockquote>
  <em>Notice that the unbounded range mimmicks the semantics of the OData-style request.</em>
</p>
<p>Response</p>
<blockquote>
  <code>416 Requested Range Not Satisfiable</code>
</blockquote>

<p><strong>Comparison</strong></p>
<p>
  The response of the Range header style request is precisely in line with the spec:
  <blockquote>
    A server SHOULD return a response with this status code if a request included a Range request-header field, and none of the range-specifier values in this field overlap the current extent of the selected resource, and the request did not include an If-Range request-header field. (For byte-ranges, this means that the first-byte-pos of all of the byte-range-spec values were greater than the current length of the selected resource.)
  </blockquote>
  Note, as well, that byte-ranges are specified here as a single use-case of the range header, firmly implying that the usage as shown here is the correct semantic usage.
</p>
<p>The OData-style is not allowed to return a <code>416</code> status code, because it never sent a Range header.  However, this header still seems semantically correct, even for OData.</p>

<h3>Additional functionality of the range header.</h3>
<p>Here are some things that the Range header supports that have no analog in the OData-style.</p>

<p><strong>Discoverability</strong></p>
<p>Request</p>
<blockquote>
  <code>OPTION /users</code>
</blockquote>
<p>Response</p>
<blockquote>
  <code>200 OK
  <br />Accept-Ranges: users</code>
</blockquote>
<p>The Range header style allows for discovery of acceptable ranges via the OPTIONS HTTP verb.

<p><strong><em>Last-n</em> requests</strong></p>
<p>Request</p>
<blockquote>
  <code>GET /users
  <br />Ranges: users=-5</code>
</blockquote>
<p>Response</p>
<blockquote>
  <code>206 Partial Content
  <br />Accept-Ranges: users
  <br />Content-Range: users 196-200/200
  <br />
  <br />[ 196..200 ]</code>
</blockquote>
<p>The Range header style allows for requests rooted at the end of the entity, rather than the begining.</p>

<p><strong>Multipart ranges</strong></p>
<p>Request</p>
<blockquote>
  <code>GET /users
  <br />Ranges: users=0-9,50-59</code>
</blockquote>
<p>Response</p>
<blockquote>
  <code>206 Partial Content
  <br />Accept-Ranges: users
  <br />Content-Type: multipart/mixed; boundary=next
  <br />
  <br />--next
  <br />Content-Range: users 0-9/200
  <br />
  <br />[ 0..9 ]
  <br />
  <br />--next
  <br />Content-Range: users 50-59/200
  <br />
  <br />[ 50..59 ]
  <br />
  <br />--next--</code>
</blockquote>
<p>The Range header style allows for requests that specify multiple ranges and HTTP supports sending these back as a multipart docuemnt.</p>

<h2>Conclustion</h2>
<p>To me, it seems that the Range header is both more powerful and more semanticaly correct than the OData-style of query string parameters (or any query string style, for that matter). As such, I will always use the standard Range HTTP header whenever I implement REST APIs.</p>
<p>I urge you to do the same.</p>
